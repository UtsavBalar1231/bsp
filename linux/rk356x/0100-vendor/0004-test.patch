From b73ec3507e05cd5ec3b0b89d508ead7b7f08790f Mon Sep 17 00:00:00 2001
From: UtsavBalar1231 <utsavbalar1231@gmail.com>
Date: Fri, 5 Jul 2024 00:19:26 +0530
Subject: [PATCH 4/8] test

Change-Id: I9d0448af6fb39046a3e48218d160a39e38fad36b
Signed-off-by: UtsavBalar1231 <utsavbalar1231@gmail.com>
---
 arch/arm64/boot/dts/rockchip/overlay/Makefile |   2 +
 .../overlay/rk3566-cm3-io-imx708-camera1.dts  | 159 +++
 .../overlay/rk3566-cm3-io-imx708-camera2.dts  | 147 +++
 .../boot/dts/rockchip/rk3566-radxa-cm3-io.dts | 123 ---
 drivers/media/i2c/imx708.c                    | 911 ++++++++++++------
 5 files changed, 924 insertions(+), 418 deletions(-)
 create mode 100644 arch/arm64/boot/dts/rockchip/overlay/rk3566-cm3-io-imx708-camera1.dts
 create mode 100644 arch/arm64/boot/dts/rockchip/overlay/rk3566-cm3-io-imx708-camera2.dts

diff --git a/arch/arm64/boot/dts/rockchip/overlay/Makefile b/arch/arm64/boot/dts/rockchip/overlay/Makefile
index 63c83e0961ca..24a31e529f75 100644
--- a/arch/arm64/boot/dts/rockchip/overlay/Makefile
+++ b/arch/arm64/boot/dts/rockchip/overlay/Makefile
@@ -65,6 +65,8 @@ dtbo-$(CONFIG_ARCH_ROCKCHIP) += \
 	rock-5b-rpi-camera-v2.dtbo \
 	rock-5b-radxa-camera-4k.dtbo \
 	rock-5b-sata.dtbo \
+	rk3566-cm3-io-imx708-camera1.dtbo \
+	rk3566-cm3-io-imx708-camera2.dtbo
 
 dtbotxt-$(CONFIG_ARCH_ROCKCHIP) += \
 	README.rockchip-overlays
diff --git a/arch/arm64/boot/dts/rockchip/overlay/rk3566-cm3-io-imx708-camera1.dts b/arch/arm64/boot/dts/rockchip/overlay/rk3566-cm3-io-imx708-camera1.dts
new file mode 100644
index 000000000000..5da9613ec736
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/overlay/rk3566-cm3-io-imx708-camera1.dts
@@ -0,0 +1,159 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/ {
+	metadata {
+		title = "Enable Raspberry Pi Camera v3 on CM3 IO v1.34+ CAM1";
+		compatible = "radxa,cm3-io";
+		category = "camera";
+		exclusive = "csi2_dphy1";
+		description = "Enable Raspberry Pi Camera v3 on CM3 IO v1.34+ CAM1.";
+	};
+};
+
+&{/} {
+	dw9817_p1: dw9817_p1@c {
+		compatible = "dongwoon,dw9817";
+		status = "okay";
+		reg = <0x0c>;
+		rockchip,camera-module-index = <0>;
+		rockchip,vcm-start-current = <10>;
+		rockchip,vcm-rated-current = <85>;
+		rockchip,vcm-step-mode = <5>;
+		rockchip,camera-module-facing = "back";
+	};
+
+	ext_cam_clk_imx708: ext-cam-clk-imx708 {
+		status = "okay";
+		compatible = "fixed-clock";
+		clock-frequency = <24000000>;
+		clock-output-names = "ext_cam_clk_imx708";
+		#clock-cells = <0>;
+	};
+
+	camera_pwdn_gpio: camera-pwdn-gpio {
+		status = "okay";
+		compatible = "regulator-fixed";
+		regulator-name = "camera_pwdn_gpio";
+		regulator-always-on;
+		regulator-boot-on;
+		enable-active-high;
+		pwdn-gpios = <&gpio4 RK_PC1 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cam_pwdn_gpio>;
+	};
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_xfer>;
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	imx708: imx708@1a {
+		status = "okay";
+		compatible = "sony,imx708";
+		reg = <0x1a>;
+		clocks = <&ext_cam_clk_imx708>;
+		clock-names = "xclk";
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "front";
+		rockchip,camera-module-name = "arducam-imx708";
+		rockchip,camera-module-lens-name = "default";
+		lens-focus = <&dw9817_p1>;
+
+		port {
+			imx708_out: endpoint {
+				remote-endpoint = <&csi2dphy1_uCAM1>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+};
+
+&csi2_dphy_hw {
+	status = "okay";
+};
+
+&csi2_dphy0 {
+	status = "disabled";
+};
+
+&csi2_dphy1 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csi2dphy1_uCAM1: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&imx708_out>;
+				data-lanes = <1 2>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csi2dphy1_out: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&isp0_in>;
+			};
+		};
+	};
+};
+
+&csi2_dphy2 {
+	status = "disabled";
+};
+
+&rkisp_vir0 {
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		isp0_in: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&csi2dphy1_out>;
+		};
+	};
+};
+
+&rkisp {
+	status = "okay";
+};
+
+&rkisp_mmu {
+	status = "okay";
+};
+
+&rkcif_mmu {
+	status = "okay";
+};
+
+&rkcif {
+	status = "okay";
+};
+
+&pinctrl {
+	camera {
+		cam_pwdn_gpio: cam-pwdn-gpio {
+			rockchip,pins = <4 RK_PC1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/overlay/rk3566-cm3-io-imx708-camera2.dts b/arch/arm64/boot/dts/rockchip/overlay/rk3566-cm3-io-imx708-camera2.dts
new file mode 100644
index 000000000000..e12b2d5c3cc5
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/overlay/rk3566-cm3-io-imx708-camera2.dts
@@ -0,0 +1,147 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/ {
+	metadata {
+		title = "Enable Raspberry Pi Camera v3 on CM3 IO v1.34+ CAM2";
+		compatible = "radxa,cm3-io";
+		category = "camera";
+		exclusive = "csi2_dphy2";
+		description = "Enable Raspberry Pi Camera v3 on CM3 IO v1.34+ CAM2.";
+	};
+};
+
+&{/} {
+	ext_cam_clk_imx708: ext-cam-clk-imx708 {
+		status = "okay";
+		compatible = "fixed-clock";
+		clock-frequency = <24000000>;
+		clock-output-names = "ext_cam_clk_imx708";
+		#clock-cells = <0>;
+	};
+
+	camera_pwdn_gpio: camera-pwdn-gpio {
+		status = "okay";
+		compatible = "regulator-fixed";
+		regulator-name = "camera_pwdn_gpio";
+		regulator-always-on;
+		regulator-boot-on;
+		enable-active-high;
+		pwdn-gpios = <&gpio3 RK_PC3 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cam_pwdn_gpio>;
+	};
+};
+
+&i2c2 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2m1_xfer>;
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	imx708: imx708@1a {
+		status = "okay";
+		compatible = "sony,imx708";
+		reg = <0x1a>;
+
+		clocks = <&ext_cam_clk_imx708>;
+		clock-names = "xclk";
+
+		rotation = <180>;
+
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "front";
+		rockchip,camera-module-name = "arducam-imx708";
+		rockchip,camera-module-lens-name = "default";
+
+		port {
+			imx708_out: endpoint {
+				remote-endpoint = <&csi2dphy2_uCAM2>;
+				data-lanes = <1 2>;
+				clock-noncontinuous;
+				link-frequencies = /bits/ 64 <450000000>;
+			};
+		};
+	};
+};
+
+&csi2_dphy_hw {
+	status = "okay";
+};
+
+&csi2_dphy2 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csi2dphy2_uCAM2: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&imx708_out>;
+				data-lanes = <1 2>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csi2dphy2_out: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&isp0_in>;
+			};
+		};
+	};
+};
+
+&rkisp_vir0 {
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		isp0_in: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&csi2dphy2_out>;
+		};
+	};
+};
+
+&rkisp {
+	status = "okay";
+};
+
+&rkisp_mmu {
+	status = "okay";
+};
+
+&rkcif_mmu {
+	status = "okay";
+};
+
+&rkcif {
+	status = "okay";
+};
+
+
+&pinctrl {
+	camera {
+		cam_pwdn_gpio: cam-pwdn-gpio {
+			rockchip,pins = <3 RK_PC3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/rockchip/rk3566-radxa-cm3-io.dts b/arch/arm64/boot/dts/rockchip/rk3566-radxa-cm3-io.dts
index f0209ee168c4..d3a22b0116bb 100644
--- a/arch/arm64/boot/dts/rockchip/rk3566-radxa-cm3-io.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3566-radxa-cm3-io.dts
@@ -111,26 +111,6 @@ vcc_ch482d2: vcc-ch482d2 {
 		regulator-boot-on;
 		status = "okay";
 	};
-
-	ext_cam_clk_imx708_0: ext-cam-clk-imx708-0 {
-		status = "okay";
-		compatible = "fixed-clock";
-		clock-frequency = <24000000>;
-		clock-output-names = "ext_cam_clk_imx708_0";
-		#clock-cells = <0>;
-	};
-
-	camera_pwdn_gpio: camera-pwdn-gpio {
-		status = "okay";
-		compatible = "regulator-fixed";
-		regulator-name = "camera_pwdn_gpio";
-		regulator-always-on;
-		regulator-boot-on;
-		enable-active-high;
-		pwdn-gpios = <&gpio4 RK_PC1 GPIO_ACTIVE_HIGH>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&cam_pwdn_gpio>;
-	};
 };
 
 &gpio_leds {
@@ -238,103 +218,6 @@ &pwm0 {
 	status = "okay";
 };
 
-&i2c0 {
-	status = "okay";
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2c0_xfer>;
-
-	#address-cells = <1>;
-	#size-cells = <0>;
-
-	imx708: imx708@1a {
-		status = "okay";
-		compatible = "sony,imx708";
-		reg = <0x1a>;
-
-		clocks = <&ext_cam_clk_imx708_0>;
-		clock-names = "xclk";
-		//reset-gpios = <&gpio3 RK_PC6 GPIO_ACTIVE_HIGH>;
-		rockchip,camera-module-index = <1>;
-		rockchip,camera-module-facing = "front";
-		rockchip,camera-module-name = "arducam-imx708";
-		rockchip,camera-module-lens-name = "default";
-
-		port {
-			imx708_0_out: endpoint {
-				remote-endpoint = <&csi2dphy1_uCAM0>;
-				data-lanes = <1 2>;
-				link-frequencies = /bits/ 64 <450000000>;
-			};
-		};
-	};
-};
-
-&csi2_dphy_hw {
-	status = "okay";
-};
-
-&csi2_dphy1 {
-	status = "okay";
-
-	ports {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		port@0 {
-			reg = <0>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-
-			csi2dphy1_uCAM0: endpoint@1 {
-				reg = <1>;
-				remote-endpoint = <&imx708_0_out>;
-				data-lanes = <1 2>;
-			};
-		};
-
-		port@1 {
-			reg = <1>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-
-			csi2dphy1_out: endpoint@1 {
-				reg = <1>;
-				remote-endpoint = <&isp0_in>;
-			};
-		};
-	};
-};
-
-&rkisp_vir0 {
-	status = "okay";
-
-	port {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		isp0_in: endpoint@0 {
-			reg = <0>;
-			remote-endpoint = <&csi2dphy1_out>;
-		};
-	};
-};
-
-&rkisp {
-	status = "okay";
-};
-
-&rkisp_mmu {
-	status = "okay";
-};
-
-&rkcif {
-	status = "okay";
-};
-
-&rkcif_mmu {
-	status = "okay";
-};
-
 &i2c2 {
 	status = "okay";
 	hym8563: hym8563@51 {
@@ -376,12 +259,6 @@ &threshold {
 };
 
 &pinctrl {
-	camera {
-		cam_pwdn_gpio: cam-pwdn-gpio {
-			rockchip,pins = <4 RK_PC1 RK_FUNC_GPIO &pcfg_pull_up>;
-		};
-	};
-
 	headphone {
 		hp_det: hp-det {
 			rockchip,pins = <4 RK_PC4 RK_FUNC_GPIO &pcfg_pull_up>;
diff --git a/drivers/media/i2c/imx708.c b/drivers/media/i2c/imx708.c
index 2e28726bbd53..ae374fe54738 100644
--- a/drivers/media/i2c/imx708.c
+++ b/drivers/media/i2c/imx708.c
@@ -3,8 +3,13 @@
  * A V4L2 driver for Sony IMX708 cameras.
  * Copyright (C) 2022, Raspberry Pi Ltd
  *
- * Based on Sony imx708 camera driver
+ * Based on Sony imx477 camera driver
  * Copyright (C) 2020 Raspberry Pi Ltd
+ *
+ * V0.0X01.0X00 first version.
+ * TODO: Implement Rockchip HDR functionality
+ * TODO: Implement EEPROM read/write
+ * TODO: Implement extraction of CSI DPHY parameters
  */
 #include <asm/unaligned.h>
 #include <linux/clk.h>
@@ -22,12 +27,24 @@
 #include <linux/rk-camera-module.h>
 #include <linux/version.h>
 
-#define DRIVER_VERSION			KERNEL_VERSION(0, 0x01, 0x03)
-#define IMX708_NAME			"imx708"
-#define OF_CAMERA_HDR_MODE		"rockchip,camera-hdr-mode"
+#define DRIVER_VERSION KERNEL_VERSION(0, 0x01, 0x00)
+
+#ifndef V4L2_CID_DIGITAL_GAIN
+#define V4L2_CID_DIGITAL_GAIN V4L2_CID_GAIN
+#endif
 
-static int debug = 0;
-module_param(debug, int, 0644);
+#define IMX708_NAME "imx708"
+#define OF_CAMERA_HDR_MODE "rockchip,camera-hdr-mode"
+
+#define IMX708_LANES 2
+
+/*
+ * Parameter to adjust Quad Bayer re-mosaic broken line correction
+ * strength, used in full-resolution mode only. Set zero to disable.
+ */
+static int qbc_adjust = 2;
+module_param(qbc_adjust, int, 0644);
+MODULE_PARM_DESC(qbc_adjust, "Quad Bayer broken line correction strength [0,2-5]");
 
 #define IMX708_REG_VALUE_08BIT		1
 #define IMX708_REG_VALUE_16BIT		2
@@ -108,22 +125,19 @@ module_param(debug, int, 0644);
 
 /* HDR exposure ratio (long:med == med:short) */
 #define IMX708_HDR_EXPOSURE_RATIO       4
-#define IMX708_REG_MID_EXPOSURE	0x3116
-#define IMX708_REG_SHT_EXPOSURE	0x0224
+#define IMX708_REG_MID_EXPOSURE		0x3116
+#define IMX708_REG_SHT_EXPOSURE		0x0224
 #define IMX708_REG_MID_ANALOG_GAIN	0x3118
 #define IMX708_REG_SHT_ANALOG_GAIN	0x0216
 
-/*
- * Metadata buffer holds a variety of data, all sent with the same VC/DT (0x12).
- * It comprises two scanlines (of up to 5760 bytes each, for 4608 pixels)
- * of embedded data, one line of PDAF data, and two lines of AE-HIST data
- * (AE histograms are valid for HDR mode and empty in non-HDR modes).
- */
-#define IMX708_EMBEDDED_LINE_WIDTH (5 * 5760)
-#define IMX708_NUM_EMBEDDED_LINES 1
+/* QBC Re-mosaic broken line correction registers */
+#define IMX708_LPF_INTENSITY_EN		0xC428
+#define IMX708_LPF_INTENSITY_ENABLED	0x00
+#define IMX708_LPF_INTENSITY_DISABLED	0x01
+#define IMX708_LPF_INTENSITY		0xC429
 
 /* IMX708 native and active pixel array size. */
-#define IMX708_NATIVE_WIDTH			4640U
+#define IMX708_NATIVE_WIDTH		4640U
 #define IMX708_NATIVE_HEIGHT		2658U
 #define IMX708_PIXEL_ARRAY_LEFT		16U
 #define IMX708_PIXEL_ARRAY_TOP		24U
@@ -176,7 +190,17 @@ struct imx708_mode {
 	/* Not all modes have the same exposure lines step. */
 	u32 exposure_lines_step;
 
-	u32 hdr_mode;
+	/* Rockchip HDR mode */
+	u32 rk_hdr_mode;
+
+	/* VC numbers for each pad */
+	u32 vc[PAD_MAX];
+
+	/* Bit depth */
+	u32 bpp;
+
+	/* Quad Bayer Re-mosaic flag */
+	bool remosaic;
 };
 
 /* Default PDAF pixel correction gains */
@@ -369,8 +393,6 @@ static const struct imx708_reg mode_4608x2592_regs[] = {
 	{0x341f, 0x20},
 	{0x3420, 0x00},
 	{0x3421, 0xd8},
-	{0xC428, 0x00},
-	{0xC429, 0x04},
 	{0x3366, 0x00},
 	{0x3367, 0x00},
 	{0x3368, 0x00},
@@ -465,10 +487,10 @@ static const struct imx708_reg mode_2x2binned_regs[] = {
 	{0x341f, 0x90},
 	{0x3420, 0x00},
 	{0x3421, 0x6c},
-	{0x3366, 0x07},
-	{0x3367, 0x80},
-	{0x3368, 0x04},
-	{0x3369, 0x38},
+	{0x3366, 0x00},
+	{0x3367, 0x00},
+	{0x3368, 0x00},
+	{0x3369, 0x00},
 };
 
 static const struct imx708_reg mode_2x2binned_720p_regs[] = {
@@ -655,14 +677,14 @@ static const struct imx708_reg mode_hdr_regs[] = {
 	{0x3421, 0x6c},
 	{0x3360, 0x01},
 	{0x3361, 0x01},
-	{0x3366, 0x07},
-	{0x3367, 0x80},
-	{0x3368, 0x04},
-	{0x3369, 0x38},
+	{0x3366, 0x09},
+	{0x3367, 0x00},
+	{0x3368, 0x05},
+	{0x3369, 0x10},
 };
 
 /* Mode configs. Keep separate lists for when HDR is enabled or not. */
-static const struct imx708_mode supported_modes[] = {
+static const struct imx708_mode supported_modes_10bit_no_hdr[] = {
 	{
 		.bus_fmt = MEDIA_BUS_FMT_SRGGB10_1X10,
 		/* Full resolution. */
@@ -688,7 +710,10 @@ static const struct imx708_mode supported_modes[] = {
 		.pixel_rate = 595200000,
 		.exposure_lines_min = 8,
 		.exposure_lines_step = 1,
-		.hdr_mode = NO_HDR,
+		.rk_hdr_mode = NO_HDR,
+		.vc[PAD0] = V4L2_MBUS_CSI2_CHANNEL_0,
+		.bpp = 10,
+		.remosaic = true
 	},
 	{
 		.bus_fmt = MEDIA_BUS_FMT_SRGGB10_1X10,
@@ -715,13 +740,49 @@ static const struct imx708_mode supported_modes[] = {
 		.pixel_rate = 585600000,
 		.exposure_lines_min = 4,
 		.exposure_lines_step = 2,
-		.hdr_mode = NO_HDR,
+		.rk_hdr_mode = NO_HDR,
+		.vc[PAD0] = V4L2_MBUS_CSI2_CHANNEL_0,
+		.bpp = 10,
+		.remosaic = false
 	},
+	{
+		.bus_fmt = MEDIA_BUS_FMT_SRGGB10_1X10,
+		/* 2x2 binned and cropped for 720p. */
+		.width = 1536,
+		.height = 864,
+		.max_fps = {
+			.numerator = 10000,
+			.denominator = 1200000,
+		},
+		.line_length_pix = 0x1460,
+		.crop = {
+			.left = IMX708_PIXEL_ARRAY_LEFT + 768,
+			.top = IMX708_PIXEL_ARRAY_TOP + 432,
+			.width = 3072,
+			.height = 1728,
+		},
+		.vblank_min = 40,
+		.vblank_default = 2755,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_2x2binned_720p_regs),
+			.regs = mode_2x2binned_720p_regs,
+		},
+		.pixel_rate = 566400000,
+		.exposure_lines_min = 4,
+		.exposure_lines_step = 2,
+		.rk_hdr_mode = NO_HDR,
+		.vc[PAD0] = V4L2_MBUS_CSI2_CHANNEL_0,
+		.bpp = 10,
+		.remosaic = false
+	},
+};
+
+static const struct imx708_mode supported_modes_10bit_hdr[] = {
 	{
 		.bus_fmt = MEDIA_BUS_FMT_SRGGB10_1X10,
 		/* There's only one HDR mode, which is 2x2 downscaled */
-		.width = 1920,
-		.height = 1080,
+		.width = 2304,
+		.height = 1296,
 		.max_fps = {
 			.numerator = 10000,
 			.denominator = 310000,
@@ -742,37 +803,65 @@ static const struct imx708_mode supported_modes[] = {
 		.pixel_rate = 777600000,
 		.exposure_lines_min = 8 * IMX708_HDR_EXPOSURE_RATIO * IMX708_HDR_EXPOSURE_RATIO,
 		.exposure_lines_step = 2 * IMX708_HDR_EXPOSURE_RATIO * IMX708_HDR_EXPOSURE_RATIO,
-		.hdr_mode = HDR_X3,
+		.rk_hdr_mode = HDR_X3,
+		.vc[PAD0] = V4L2_MBUS_CSI2_CHANNEL_2,
+		.vc[PAD1] = V4L2_MBUS_CSI2_CHANNEL_1,//M->csi wr0
+		.vc[PAD2] = V4L2_MBUS_CSI2_CHANNEL_0,//L->csi wr0
+		.vc[PAD3] = V4L2_MBUS_CSI2_CHANNEL_2,//S->csi wr2
+		.bpp = 10,
+		.remosaic = false
 	},
 	{
 		.bus_fmt = MEDIA_BUS_FMT_SRGGB10_1X10,
-		/* 2x2 binned and cropped for 720p. */
-		.width = 1536,
-		.height = 864,
+		/* There's only one HDR mode, which is 2x2 downscaled */
+		.width = 1920,
+		.height = 1080,
 		.max_fps = {
 			.numerator = 10000,
-			.denominator = 1200000,
+			.denominator = 310000,
 		},
 		.line_length_pix = 0x1460,
 		.crop = {
-			.left = IMX708_PIXEL_ARRAY_LEFT + 768,
-			.top = IMX708_PIXEL_ARRAY_TOP + 432,
-			.width = 3072,
-			.height = 1728,
+			.left = IMX708_PIXEL_ARRAY_LEFT,
+			.top = IMX708_PIXEL_ARRAY_TOP,
+			.width = 4608,
+			.height = 2592,
 		},
-		.vblank_min = 40,
-		.vblank_default = 2755,
+		.vblank_min = 3673,
+		.vblank_default = 3673,
 		.reg_list = {
-			.num_of_regs = ARRAY_SIZE(mode_2x2binned_720p_regs),
-			.regs = mode_2x2binned_720p_regs,
+			.num_of_regs = ARRAY_SIZE(mode_hdr_regs),
+			.regs = mode_hdr_regs,
 		},
-		.pixel_rate = 566400000,
-		.exposure_lines_min = 4,
-		.exposure_lines_step = 2,
-		.hdr_mode = NO_HDR,
-	},
+		.pixel_rate = 777600000,
+		.exposure_lines_min = 8 * IMX708_HDR_EXPOSURE_RATIO * IMX708_HDR_EXPOSURE_RATIO,
+		.exposure_lines_step = 2 * IMX708_HDR_EXPOSURE_RATIO * IMX708_HDR_EXPOSURE_RATIO,
+		.rk_hdr_mode = HDR_X3,
+		.vc[PAD0] = V4L2_MBUS_CSI2_CHANNEL_2,
+		.vc[PAD1] = V4L2_MBUS_CSI2_CHANNEL_1,//M->csi wr0
+		.vc[PAD2] = V4L2_MBUS_CSI2_CHANNEL_0,//L->csi wr0
+		.vc[PAD3] = V4L2_MBUS_CSI2_CHANNEL_2,//S->csi wr2
+		.bpp = 10,
+		.remosaic = false
+	}
 };
 
+/*
+ * The supported formats.
+ * This table MUST contain 4 entries per format, to cover the various flip
+ * combinations in the order
+ * - no flip
+ * - h flip
+ * - v flip
+ * - h&v flips
+ */
+static const u32 codes[] = {
+	/* 10-bit modes. */
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+};
 
 static const char * const imx708_test_pattern_menu[] = {
 	"Disabled",
@@ -811,30 +900,34 @@ static const char * const imx708_supply_name[] = {
 #define IMX708_XCLR_DELAY_RANGE_US	1000
 
 struct imx708 {
-	struct i2c_client	*client;
-	struct clk *inclk;
-	struct gpio_desc *reset_gpio;
-
-	struct regulator_bulk_data supplies[ARRAY_SIZE(imx708_supply_name)];
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct i2c_client *client;
 
 	struct v4l2_mbus_framefmt fmt;
 
+	struct clk *inclk;
 	u32 inclk_freq;
 
-	struct v4l2_subdev subdev;
-	struct media_pad pad;
+	struct gpio_desc *reset_gpio;
+	struct regulator_bulk_data supplies[ARRAY_SIZE(imx708_supply_name)];
+
 	struct v4l2_ctrl_handler ctrl_handler;
 	/* V4L2 Controls */
 	struct v4l2_ctrl *pixel_rate;
 	struct v4l2_ctrl *exposure;
 	struct v4l2_ctrl *vblank;
 	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *hdr_mode;
 	struct v4l2_ctrl *link_freq;
 	struct {
 		struct v4l2_ctrl *hflip;
 		struct v4l2_ctrl *vflip;
 	};
 
+	/* Current mode */
+	const struct imx708_mode *mode;
+
 	/*
 	 * Mutex for serialized access:
 	 * Protect sensor module set pad format and start/stop streaming safely.
@@ -845,11 +938,9 @@ struct imx708 {
 	bool streaming;
 	bool power_on;
 
-	/* Current mode */
-	const struct imx708_mode *cur_mode;
-	/*module*/
-	u32 		module_index;
-	u32			cfg_num;
+	/* Rockchip module */
+	u32 module_index;
+	u32 cfg_num;
 	const char *module_facing;
 	const char *module_name;
 	const char *len_name;
@@ -865,13 +956,38 @@ struct imx708 {
 
 static inline struct imx708 *to_imx708(struct v4l2_subdev *_sd)
 {
-	return container_of(_sd, struct imx708, subdev);
+	return container_of(_sd, struct imx708, sd);
+}
+
+static inline void get_mode_table(unsigned int code,
+				  const struct imx708_mode **mode_list,
+				  unsigned int *num_modes,
+				  bool hdr_enable)
+{
+	switch (code) {
+	/* 10-bit */
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+		if (hdr_enable) {
+			*mode_list = supported_modes_10bit_hdr;
+			*num_modes = ARRAY_SIZE(supported_modes_10bit_hdr);
+		} else {
+			*mode_list = supported_modes_10bit_no_hdr;
+			*num_modes = ARRAY_SIZE(supported_modes_10bit_no_hdr);
+		}
+		break;
+	default:
+		*mode_list = NULL;
+		*num_modes = 0;
+	}
 }
 
 /* Read registers up to 2 at a time */
 static int imx708_read_reg(struct imx708 *imx708, u16 reg, u32 len, u32 *val)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&imx708->subdev);
+	struct i2c_client *client = v4l2_get_subdevdata(&imx708->sd);
 	struct i2c_msg msgs[2];
 	u8 addr_buf[2] = { reg >> 8, reg & 0xff };
 	u8 data_buf[4] = { 0, };
@@ -904,7 +1020,7 @@ static int imx708_read_reg(struct imx708 *imx708, u16 reg, u32 len, u32 *val)
 /* Write registers up to 2 at a time */
 static int imx708_write_reg(struct imx708 *imx708, u16 reg, u32 len, u32 val)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&imx708->subdev);
+	struct i2c_client *client = v4l2_get_subdevdata(&imx708->sd);
 	u8 buf[6];
 
 	if (len > 4)
@@ -922,7 +1038,7 @@ static int imx708_write_reg(struct imx708 *imx708, u16 reg, u32 len, u32 val)
 static int imx708_write_regs(struct imx708 *imx708,
 			     const struct imx708_reg *regs, u32 len)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&imx708->subdev);
+	struct i2c_client *client = v4l2_get_subdevdata(&imx708->sd);
 	unsigned int i;
 
 	for (i = 0; i < len; i++) {
@@ -941,30 +1057,74 @@ static int imx708_write_regs(struct imx708 *imx708,
 	return 0;
 }
 
-#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API
+/* Get bayer order based on flip setting. */
+static u32 imx708_get_format_code(struct imx708 *imx708)
+{
+	unsigned int i;
+
+	lockdep_assert_held(&imx708->mutex);
+
+	i = (imx708->vflip->val ? 2 : 0) |
+	    (imx708->hflip->val ? 1 : 0);
+
+	return codes[i];
+}
+
+static void imx708_set_default_format(struct imx708 *imx708)
+{
+	struct v4l2_mbus_framefmt *fmt = &imx708->fmt;
+
+	/* Set default mode to max resolution */
+	imx708->mode = &supported_modes_10bit_no_hdr[0];
+
+	/* fmt->code not set as it will always be computed based on flips */
+	fmt->colorspace = V4L2_COLORSPACE_RAW;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true,
+							  fmt->colorspace,
+							  fmt->ycbcr_enc);
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+	fmt->width = imx708->mode->width;
+	fmt->height = imx708->mode->height;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
 static int imx708_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 {
 	struct imx708 *imx708 = to_imx708(sd);
 	struct v4l2_mbus_framefmt *try_fmt_img =
 		v4l2_subdev_get_try_format(sd, fh->pad, 0);
+	struct v4l2_rect *try_crop;
 
 	mutex_lock(&imx708->mutex);
 
-	try_fmt_img->width = supported_modes[0].width;
-	try_fmt_img->height = supported_modes[0].height;
-	try_fmt_img->code =  supported_modes[0].bus_fmt;
+	/* Initialize try_fmt for the image pad */
+	if (imx708->hdr_mode->val) {
+		try_fmt_img->width = supported_modes_10bit_hdr[0].width;
+		try_fmt_img->height = supported_modes_10bit_hdr[0].height;
+	} else {
+		try_fmt_img->width = supported_modes_10bit_no_hdr[0].width;
+		try_fmt_img->height = supported_modes_10bit_no_hdr[0].height;
+	}
+	try_fmt_img->code = imx708_get_format_code(imx708);
 	try_fmt_img->field = V4L2_FIELD_NONE;
 
+	/* Initialize try_crop */
+	try_crop = v4l2_subdev_get_try_crop(sd, fh->pad, 0);
+	try_crop->left = IMX708_PIXEL_ARRAY_LEFT;
+	try_crop->top = IMX708_PIXEL_ARRAY_TOP;
+	try_crop->width = IMX708_PIXEL_ARRAY_WIDTH;
+	try_crop->height = IMX708_PIXEL_ARRAY_HEIGHT;
+
 	mutex_unlock(&imx708->mutex);
 
 	return 0;
 }
-#endif
 
 static int imx708_set_exposure(struct imx708 *imx708, unsigned int val)
 {
-	val = max(val, imx708->cur_mode->exposure_lines_min);
-	val -= val % imx708->cur_mode->exposure_lines_step;
+	val = max(val, imx708->mode->exposure_lines_min);
+	val -= val % imx708->mode->exposure_lines_step;
 
 	/*
 	 * In HDR mode this will set the longest exposure. The sensor
@@ -981,7 +1141,7 @@ static void imx708_adjust_exposure_range(struct imx708 *imx708,
 	int exposure_max, exposure_def;
 
 	/* Honour the VBLANK limits when setting exposure. */
-	exposure_max = imx708->cur_mode->height + imx708->vblank->val -
+	exposure_max = imx708->mode->height + imx708->vblank->val -
 		IMX708_EXPOSURE_OFFSET;
 	exposure_def = min(exposure_max, imx708->exposure->val);
 	__v4l2_ctrl_modify_range(imx708->exposure, imx708->exposure->minimum,
@@ -1025,7 +1185,7 @@ static int imx708_set_frame_length(struct imx708 *imx708, unsigned int val)
 
 static void imx708_set_framing_limits(struct imx708 *imx708)
 {
-	const struct imx708_mode *mode = imx708->cur_mode;
+	const struct imx708_mode *mode = imx708->mode;
 	unsigned int hblank;
 
 	__v4l2_ctrl_modify_range(imx708->pixel_rate,
@@ -1051,8 +1211,11 @@ static int imx708_set_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct imx708 *imx708 =
 		container_of(ctrl->handler, struct imx708, ctrl_handler);
-	struct i2c_client *client = imx708->client;
+	struct i2c_client *client = v4l2_get_subdevdata(&imx708->sd);
+	const struct imx708_mode *mode_list;
+	unsigned int code, num_modes;
 	int ret = 0;
+	bool hdr;
 
 	switch (ctrl->id) {
 	case V4L2_CID_VBLANK:
@@ -1062,6 +1225,25 @@ static int imx708_set_ctrl(struct v4l2_ctrl *ctrl)
 		 */
 		imx708_adjust_exposure_range(imx708, ctrl);
 		break;
+
+	case V4L2_CID_WIDE_DYNAMIC_RANGE:
+		/*
+		 * The WIDE_DYNAMIC_RANGE control can also be applied immediately
+		 * as it doesn't set any registers. Don't do anything if the mode
+		 * already matches.
+		 */
+		hdr = imx708->mode->rk_hdr_mode != NO_HDR;
+		if (imx708->mode && hdr != ctrl->val) {
+			code = imx708_get_format_code(imx708);
+			get_mode_table(code, &mode_list, &num_modes, ctrl->val);
+			imx708->mode = v4l2_find_nearest_size(mode_list,
+							      num_modes,
+							      width, height,
+							      imx708->mode->width,
+							      imx708->mode->height);
+			imx708_set_framing_limits(imx708);
+		}
+		break;
 	}
 
 	/*
@@ -1111,7 +1293,20 @@ static int imx708_set_ctrl(struct v4l2_ctrl *ctrl)
 		break;
 	case V4L2_CID_VBLANK:
 		ret = imx708_set_frame_length(imx708,
-					      imx708->cur_mode->height + ctrl->val);
+					      imx708->mode->height + ctrl->val);
+		break;
+	case V4L2_CID_NOTIFY_GAINS:
+		ret = imx708_write_reg(imx708, IMX708_REG_COLOUR_BALANCE_BLUE,
+				       IMX708_REG_VALUE_16BIT,
+				       ctrl->p_new.p_u32[0]);
+		if (ret)
+			break;
+		ret = imx708_write_reg(imx708, IMX708_REG_COLOUR_BALANCE_RED,
+				       IMX708_REG_VALUE_16BIT,
+				       ctrl->p_new.p_u32[3]);
+		break;
+	case V4L2_CID_WIDE_DYNAMIC_RANGE:
+		/* Already handled above. */
 		break;
 	default:
 		dev_info(&client->dev,
@@ -1134,11 +1329,9 @@ static int imx708_g_frame_interval(struct v4l2_subdev *sd,
 				   struct v4l2_subdev_frame_interval *fi)
 {
 	struct imx708 *imx708 = to_imx708(sd);
-	const struct imx708_mode *mode = imx708->cur_mode;
+	const struct imx708_mode *mode = imx708->mode;
 
-	mutex_lock(&imx708->mutex);
 	fi->interval = mode->max_fps;
-	mutex_unlock(&imx708->mutex);
 
 	return 0;
 }
@@ -1148,10 +1341,11 @@ static int imx708_enum_mbus_code(struct v4l2_subdev *sd,
 				 struct v4l2_subdev_mbus_code_enum *code)
 {
 	struct imx708 *imx708 = to_imx708(sd);
-		if (code->index >= imx708->cfg_num)
-			return -EINVAL;
 
-	code->code = supported_modes[code->index].bus_fmt;
+	if (code->index >= (ARRAY_SIZE(codes) / 4))
+		return -EINVAL;
+
+	code->code = imx708_get_format_code(imx708);
 
 	return 0;
 }
@@ -1160,103 +1354,101 @@ static int imx708_enum_frame_size(struct v4l2_subdev *sd,
 				  struct v4l2_subdev_pad_config *cfg,
 				  struct v4l2_subdev_frame_size_enum *fse)
 {
+
 	struct imx708 *imx708 = to_imx708(sd);
+	const struct imx708_mode *mode_list;
+	unsigned int num_modes;
 
+	get_mode_table(fse->code, &mode_list, &num_modes,
+			   imx708->hdr_mode->val);
 
-		if (fse->index >= imx708->cfg_num)
-			return -EINVAL;
+	if (fse->index >= num_modes)
+		return -EINVAL;
 
-		if (fse->code != supported_modes[fse->index].bus_fmt)
-			return -EINVAL;
+	if (fse->code != imx708_get_format_code(imx708))
+		return -EINVAL;
 
-		fse->min_width = supported_modes[fse->index].width;
-		fse->max_width = fse->min_width;;
-		fse->min_height = supported_modes[fse->index].height;
-		fse->max_height = fse->min_height;;
+	fse->min_width = mode_list[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = mode_list[fse->index].height;
+	fse->max_height = fse->min_height;
 
 	return 0;
 }
 
+static void imx708_reset_colorspace(struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->colorspace = V4L2_COLORSPACE_RAW;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true,
+							  fmt->colorspace,
+							  fmt->ycbcr_enc);
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+}
+
+static void imx708_update_image_pad_format(struct imx708 *imx708,
+					   const struct imx708_mode *mode,
+					   struct v4l2_subdev_format *fmt)
+{
+	fmt->format.width = mode->width;
+	fmt->format.height = mode->height;
+	fmt->format.field = V4L2_FIELD_NONE;
+	imx708_reset_colorspace(&fmt->format);
+}
+
 static int imx708_get_pad_format(struct v4l2_subdev *sd,
 				 struct v4l2_subdev_pad_config *cfg,
 				 struct v4l2_subdev_format *fmt)
 {
 	struct imx708 *imx708 = to_imx708(sd);
-	const struct imx708_mode *mode = imx708->cur_mode;
 
 	mutex_lock(&imx708->mutex);
 
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
-#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API
-		fmt->format = *v4l2_subdev_get_try_format(sd, cfg,
-						   fmt->pad);
-#else
-		mutex_unlock(&imx477->mutex);
-		return -ENOTTY;
-#endif
+		struct v4l2_mbus_framefmt *try_fmt =
+			v4l2_subdev_get_try_format(&imx708->sd, cfg, fmt->pad);
+		/* update the code which could change due to vflip or hflip */
+		try_fmt->code = imx708_get_format_code(imx708);
+		fmt->format = *try_fmt;
 	} else {
-		fmt->format.width = mode->width;
-		fmt->format.height = mode->height;
-		fmt->format.code = mode->bus_fmt;
-		fmt->format.field = V4L2_FIELD_NONE;
+		imx708_update_image_pad_format(imx708, imx708->mode, fmt);
+		fmt->format.code = imx708_get_format_code(imx708);
 	}
 
 	mutex_unlock(&imx708->mutex);
 	return 0;
 }
 
-static int imx708_get_reso_dist(const struct imx708_mode *mode,
-				struct v4l2_mbus_framefmt *framefmt)
-{
-	return abs(mode->width - framefmt->width) +
-	       abs(mode->height - framefmt->height);
-}
-
-static const struct imx708_mode *
-imx708_find_best_fit(struct imx708 *imx708, struct v4l2_subdev_format *fmt)
-{
-	struct v4l2_mbus_framefmt *framefmt = &fmt->format;
-	int dist;
-	int cur_best_fit = 0;
-	int cur_best_fit_dist = -1;
-	unsigned int i;
-
-	for (i = 0; i < imx708->cfg_num; i++) {
-		dist = imx708_get_reso_dist(&supported_modes[i], framefmt);
-		if ((cur_best_fit_dist == -1 || dist < cur_best_fit_dist) &&
-			supported_modes[i].bus_fmt == framefmt->code) {
-			cur_best_fit_dist = dist;
-			cur_best_fit = i;
-		}
-	}
-	dev_info(&imx708->client->dev, "%s: cur_best_fit(%d)",
-		 __func__, cur_best_fit);
-
-	return &supported_modes[cur_best_fit];
-}
-
 static int imx708_set_pad_format(struct v4l2_subdev *sd,
 				 struct v4l2_subdev_pad_config *cfg,
 				 struct v4l2_subdev_format *fmt)
 {
-	const struct imx708_mode *mode;
 	struct imx708 *imx708 = to_imx708(sd);
+	struct v4l2_mbus_framefmt *framefmt;
+	const struct imx708_mode *mode;
+	const struct imx708_mode *mode_list;
+	unsigned int num_modes;
 
 	mutex_lock(&imx708->mutex);
-	mode = imx708_find_best_fit(imx708,fmt);
-	fmt->format.code = mode->bus_fmt;
-	fmt->format.width = mode->width;
-	fmt->format.height = mode->height;
-	fmt->format.field = V4L2_FIELD_NONE;
+
+	/* Bayer order varies with flips */
+	fmt->format.code = imx708_get_format_code(imx708);
+
+	get_mode_table(fmt->format.code, &mode_list, &num_modes,
+			   imx708->hdr_mode->val);
+
+	mode = v4l2_find_nearest_size(mode_list,
+					  num_modes,
+					  width, height,
+					  fmt->format.width,
+					  fmt->format.height);
+	imx708_update_image_pad_format(imx708, mode, fmt);
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
-#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API
-		*v4l2_subdev_get_try_format(sd, cfg, fmt->pad) = fmt->format;
-#else
-		mutex_unlock(&imx708->mutex);
-		return -ENOTTY;
-#endif
+		framefmt = v4l2_subdev_get_try_format(sd, cfg,
+							  fmt->pad);
+		*framefmt = fmt->format;
 	} else {
-		imx708->cur_mode = mode;
+		imx708->mode = mode;
 		imx708_set_framing_limits(imx708);
 	}
 
@@ -1265,10 +1457,61 @@ static int imx708_set_pad_format(struct v4l2_subdev *sd,
 	return 0;
 }
 
+static const struct v4l2_rect *
+__imx708_get_pad_crop(struct imx708 *imx708, struct v4l2_subdev_pad_config *cfg,
+		      unsigned int pad, enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_crop(&imx708->sd, cfg, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &imx708->mode->crop;
+	}
+
+	return NULL;
+}
+
+static int imx708_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP: {
+		struct imx708 *imx708 = to_imx708(sd);
+
+		mutex_lock(&imx708->mutex);
+		sel->r = *__imx708_get_pad_crop(imx708, cfg, sel->pad,
+						sel->which);
+		mutex_unlock(&imx708->mutex);
+
+		return 0;
+	}
+
+	case V4L2_SEL_TGT_NATIVE_SIZE:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = IMX708_NATIVE_WIDTH;
+		sel->r.height = IMX708_NATIVE_HEIGHT;
+
+		return 0;
+
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = IMX708_PIXEL_ARRAY_LEFT;
+		sel->r.top = IMX708_PIXEL_ARRAY_TOP;
+		sel->r.width = IMX708_PIXEL_ARRAY_WIDTH;
+		sel->r.height = IMX708_PIXEL_ARRAY_HEIGHT;
+
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
 /* Start streaming */
 static int imx708_start_streaming(struct imx708 *imx708)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&imx708->subdev);
+	struct i2c_client *client = v4l2_get_subdevdata(&imx708->sd);
 	const struct imx708_reg_list *reg_list, *freq_regs;
 	int i, ret;
 	u32 val;
@@ -1308,7 +1551,7 @@ static int imx708_start_streaming(struct imx708 *imx708)
 	}
 
 	/* Apply default values of current mode */
-	reg_list = &imx708->cur_mode->reg_list;
+	reg_list = &imx708->mode->reg_list;
 	ret = imx708_write_regs(imx708, reg_list->regs, reg_list->num_of_regs);
 	if (ret) {
 		dev_err(&client->dev, "%s failed to set mode\n", __func__);
@@ -1325,8 +1568,23 @@ static int imx708_start_streaming(struct imx708 *imx708)
 		return ret;
 	}
 
+	/* Quad Bayer re-mosaic adjustments (for full-resolution mode only) */
+	if (imx708->mode->remosaic && qbc_adjust > 0) {
+		imx708_write_reg(imx708, IMX708_LPF_INTENSITY,
+				 IMX708_REG_VALUE_08BIT, qbc_adjust);
+		imx708_write_reg(imx708,
+				 IMX708_LPF_INTENSITY_EN,
+				 IMX708_REG_VALUE_08BIT,
+				 IMX708_LPF_INTENSITY_ENABLED);
+	} else {
+		imx708_write_reg(imx708,
+				 IMX708_LPF_INTENSITY_EN,
+				 IMX708_REG_VALUE_08BIT,
+				 IMX708_LPF_INTENSITY_DISABLED);
+	}
+
 	/* Apply customized values from user */
-	ret =  __v4l2_ctrl_handler_setup(imx708->subdev.ctrl_handler);
+	ret =  __v4l2_ctrl_handler_setup(imx708->sd.ctrl_handler);
 	if (ret)
 		return ret;
 
@@ -1338,7 +1596,7 @@ static int imx708_start_streaming(struct imx708 *imx708)
 /* Stop streaming */
 static void imx708_stop_streaming(struct imx708 *imx708)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&imx708->subdev);
+	struct i2c_client *client = v4l2_get_subdevdata(&imx708->sd);
 	int ret;
 
 	/* set stream off register */
@@ -1384,6 +1642,7 @@ static int imx708_set_stream(struct v4l2_subdev *sd, int enable)
 	/* vflip/hflip and hdr mode cannot change during streaming */
 	__v4l2_ctrl_grab(imx708->vflip, enable);
 	__v4l2_ctrl_grab(imx708->hflip, enable);
+	__v4l2_ctrl_grab(imx708->hdr_mode, enable);
 
 	mutex_unlock(&imx708->mutex);
 
@@ -1420,13 +1679,11 @@ static int imx708_power_on(struct device *dev)
 		goto reg_off;
 	}
 
-	gpiod_direction_output(imx708->reset_gpio, 1);
+	if (!IS_ERR(imx708->reset_gpio))
+		gpiod_set_value_cansleep(imx708->reset_gpio, 1);
 	usleep_range(IMX708_XCLR_MIN_DELAY_US,
 		     IMX708_XCLR_MIN_DELAY_US + IMX708_XCLR_DELAY_RANGE_US);
 
-	v4l2_dbg(1, debug, &imx708->subdev,"%s.\n", __func__);
-
-
 	return 0;
 
 reg_off:
@@ -1441,7 +1698,8 @@ static int imx708_power_off(struct device *dev)
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct imx708 *imx708 = to_imx708(sd);
 
-	gpiod_direction_output(imx708->reset_gpio, 0);
+	if (!IS_ERR(imx708->reset_gpio))
+		gpiod_set_value_cansleep(imx708->reset_gpio, 0);
 	regulator_bulk_disable(ARRAY_SIZE(imx708_supply_name),
 			       imx708->supplies);
 	clk_disable_unprepare(imx708->inclk);
@@ -1449,8 +1707,6 @@ static int imx708_power_off(struct device *dev)
 	/* Force reprogramming of the common registers when powered up again. */
 	imx708->common_regs_written = false;
 
-	v4l2_dbg(1, debug, &imx708->subdev,"%s.\n", __func__);
-
 	return 0;
 }
 
@@ -1489,7 +1745,7 @@ static int __maybe_unused imx708_resume(struct device *dev)
 
 static int imx708_get_regulators(struct imx708 *imx708)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&imx708->subdev);
+	struct i2c_client *client = v4l2_get_subdevdata(&imx708->sd);
 	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(imx708_supply_name); i++)
@@ -1503,7 +1759,7 @@ static int imx708_get_regulators(struct imx708 *imx708)
 /* Verify chip ID */
 static int imx708_identify_module(struct imx708 *imx708)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&imx708->subdev);
+	struct i2c_client *client = v4l2_get_subdevdata(&imx708->sd);
 	int ret;
 	u32 val;
 
@@ -1524,7 +1780,7 @@ static int imx708_identify_module(struct imx708 *imx708)
 	ret = imx708_read_reg(imx708, 0x0000, IMX708_REG_VALUE_16BIT, &val);
 	if (!ret) {
 		dev_info(&client->dev, "camera module ID 0x%04x\n", val);
-		snprintf(imx708->subdev.name, sizeof(imx708->subdev.name), "imx708%s%s",
+		snprintf(imx708->sd.name, sizeof(imx708->sd.name), "imx708%s%s",
 			 val & 0x02 ? "_wide" : "",
 			 val & 0x80 ? "_noir" : "");
 	}
@@ -1554,27 +1810,26 @@ static int imx708_s_power(struct v4l2_subdev *sd, int on)
 		pm_runtime_put(&client->dev);
 		imx708->power_on = false;
 	}
-	v4l2_dbg(1, debug, &imx708->subdev,"%s: %d.\n", __func__, on);
 unlock_and_return:
 	mutex_unlock(&imx708->mutex);
 
 	return ret;
 }
 
-
 static int imx708_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad_id,
 				struct v4l2_mbus_config *config)
 {
-	// struct imx708 *imx708 = to_imx708(sd);
-	// const struct imx708_mode *mode = imx708->cur_mode;
-
+	struct imx708 *imx708 = to_imx708(sd);
+	const struct imx708_mode *mode = imx708->mode;
 	u32 val = 0;
 
-	val = 1 << 1/*(imx708->lanes - 1)*/|
-		  V4L2_MBUS_CSI2_CHANNEL_0 |
+	val = 1 << (IMX708_LANES - 1) |
+	      V4L2_MBUS_CSI2_CHANNEL_0 |
 	      V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
-	// if (mode->hdr_mode != NO_HDR)
-	// 	val |= V4L2_MBUS_CSI2_CHANNEL_1;
+	if (mode->rk_hdr_mode != NO_HDR)
+		val |= V4L2_MBUS_CSI2_CHANNEL_1;
+	if (mode->rk_hdr_mode == HDR_X3)
+		val |= V4L2_MBUS_CSI2_CHANNEL_2;
 
 	config->type = V4L2_MBUS_CSI2_DPHY;
 	config->flags = val;
@@ -1590,41 +1845,53 @@ static void imx708_get_module_inf(struct imx708 *imx708,
 	strlcpy(inf->base.module, imx708->module_name,
 		sizeof(inf->base.module));
 	strlcpy(inf->base.lens, imx708->len_name, sizeof(inf->base.lens));
+}
+
+static int imx708_get_channel_info(struct imx708 *imx708,
+				   struct rkmodule_channel_info *ch_info)
+{
+	if (ch_info->index < PAD0 || ch_info->index >= PAD_MAX)
+		return -EINVAL;
+
+	ch_info->vc = imx708->mode->vc[ch_info->index];
+	ch_info->width = imx708->mode->width;
+	ch_info->height = imx708->mode->height;
+	ch_info->bus_fmt = imx708->mode->bus_fmt;
 
-	v4l2_dbg(1, debug, &imx708->subdev,"%s: get_module_inf:%s, %s, %s.\n", __func__,
-		inf->base.sensor, inf->base.module, inf->base.lens);
+	return 0;
 }
 
 static long imx708_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
 	struct imx708 *imx708 = to_imx708(sd);
 	struct rkmodule_hdr_cfg *hdr;
+	struct rkmodule_channel_info *ch_info;
+	//struct rkmodule_csi_dphy_param *dphy_param;
 	u32 i, h, w;
 	long ret = 0;
-	// struct rkmodule_csi_dphy_param *dphy_param;
+	u32 stream = 0;
 
-	switch (cmd)
-	{
+	switch (cmd) {
 	case RKMODULE_GET_MODULE_INFO:
 		imx708_get_module_inf(imx708, (struct rkmodule_inf *)arg);
 		break;
-	// case RKMODULE_GET_HDR_CFG:
-	// 		hdr = (struct rkmodule_hdr_cfg *)arg;
-	// 		if (imx708->cur_mode->hdr_mode == NO_HDR)
-	// 			hdr->esp.mode = HDR_NORMAL_VC;
-	// 		else
-	// 			hdr->esp.mode = HDR_ID_CODE;
-	// 		hdr->hdr_mode = imx708->cur_mode->hdr_mode;
-	// 		break;
+	case RKMODULE_GET_HDR_CFG:
+		hdr = (struct rkmodule_hdr_cfg *)arg;
+		if (imx708->mode->rk_hdr_mode == NO_HDR)
+			hdr->esp.mode = HDR_NORMAL_VC;
+		else
+			hdr->esp.mode = HDR_ID_CODE;
+		hdr->hdr_mode = imx708->mode->rk_hdr_mode;
+		break;
 	case RKMODULE_SET_HDR_CFG:
 		hdr = (struct rkmodule_hdr_cfg *)arg;
-		w = imx708->cur_mode->width;
-		h = imx708->cur_mode->height;
+		w = imx708->mode->width;
+		h = imx708->mode->height;
 		for (i = 0; i < imx708->cfg_num; i++) {
-			if (w == supported_modes[i].width &&
-			    h == supported_modes[i].height &&
-			    supported_modes[i].hdr_mode == hdr->hdr_mode) {
-				imx708->cur_mode = &supported_modes[i];
+			if (w == supported_modes_10bit_hdr[i].width &&
+			    h == supported_modes_10bit_hdr[i].height &&
+			    supported_modes_10bit_hdr[i].rk_hdr_mode == hdr->hdr_mode) {
+				imx708->mode = &supported_modes_10bit_hdr[i];
 				break;
 			}
 		}
@@ -1637,16 +1904,35 @@ static long imx708_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 			imx708_set_framing_limits(imx708);
 		}
 		break;
+	case RKMODULE_SET_QUICK_STREAM:
+		stream = *((u32 *)arg);
+
+		if (stream)
+			ret = imx708_write_reg(imx708,
+					       IMX708_REG_MODE_SELECT,
+					       IMX708_REG_VALUE_08BIT,
+					       IMX708_MODE_STREAMING);
+		else
+			ret = imx708_write_reg(imx708,
+					       IMX708_REG_MODE_SELECT,
+					       IMX708_REG_VALUE_08BIT,
+					       IMX708_MODE_STANDBY);
+		break;
+	case RKMODULE_GET_CHANNEL_INFO:
+		ch_info = (struct rkmodule_channel_info *)arg;
+		ret = imx708_get_channel_info(imx708, ch_info);
+		break;
+
 	// case RKMODULE_GET_CSI_DPHY_PARAM:
-	// 	if (imx708->cur_mode->hdr_mode == HDR_X2) {
-	// 		dphy_param = (struct rkmodule_csi_dphy_param *)arg;
-	// 		if (dphy_param->vendor == dcphy_param.vendor)
-	// 			*dphy_param = dcphy_param;
-	// 		dev_info(&imx708->client->dev,
-	// 			 "get sensor dphy param\n");
-	// 	} else
-	// 		ret = -EINVAL;
-	// 	break;
+	//	if (imx708->mode->hdr_mode == HDR_X2) {
+	//		dphy_param = (struct rkmodule_csi_dphy_param *)arg;
+	//		if (dphy_param->vendor == dcphy_param.vendor)
+	//			*dphy_param = dcphy_param;
+	//		dev_info(&imx708->client->dev,
+	//			 "get sensor dphy param\n");
+	//	} else
+	//		ret = -EINVAL;
+	//	break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
@@ -1655,14 +1941,16 @@ static long imx708_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 }
 
 #ifdef CONFIG_COMPAT
-static long imx708_compat_ioctl32(struct v4l2_subdev *sd,
-				  unsigned int cmd, unsigned long arg)
+static long imx708_compat_ioctl32(struct v4l2_subdev *sd, unsigned int cmd,
+				  unsigned long arg)
 {
 	void __user *up = compat_ptr(arg);
 	struct rkmodule_inf *inf;
 	struct rkmodule_awb_cfg *cfg;
 	struct rkmodule_hdr_cfg *hdr;
+	struct rkmodule_channel_info *ch_info;
 	long ret;
+	u32 stream = 0;
 	// struct rkmodule_csi_dphy_param *dphy_param;
 
 	switch (cmd) {
@@ -1726,44 +2014,72 @@ static long imx708_compat_ioctl32(struct v4l2_subdev *sd,
 		ret = imx708_ioctl(sd, cmd, hdr);
 		kfree(hdr);
 		break;
-	// case RKMODULE_GET_CSI_DPHY_PARAM:
-	// 	dphy_param = kzalloc(sizeof(*dphy_param), GFP_KERNEL);
-	// 	if (!dphy_param) {
-	// 		ret = -ENOMEM;
-	// 		return ret;
-	// 	}
-
-	// 	ret = imx708_ioctl(sd, cmd, dphy_param);
-	// 	if (!ret) {
-	// 		ret = copy_to_user(up, dphy_param, sizeof(*dphy_param));
-	// 		if (ret)
-	// 			ret = -EFAULT;
-	// 	}
-	// 	kfree(dphy_param);
-	// 	break;
+		// case RKMODULE_GET_CSI_DPHY_PARAM:
+		//	dphy_param = kzalloc(sizeof(*dphy_param), GFP_KERNEL);
+		//	if (!dphy_param) {
+		//		ret = -ENOMEM;
+		//		return ret;
+		//	}
+
+		//	ret = imx708_ioctl(sd, cmd, dphy_param);
+		//	if (!ret) {
+		//		ret = copy_to_user(up, dphy_param, sizeof(*dphy_param));
+		//		if (ret)
+		//			ret = -EFAULT;
+		//	}
+		//	kfree(dphy_param);
+		//	break;
+	case RKMODULE_SET_QUICK_STREAM:
+		ret = copy_from_user(&stream, up, sizeof(u32));
+		if (!ret)
+			ret = imx708_ioctl(sd, cmd, &stream);
+		else
+			ret = -EFAULT;
+
+		break;
+	case RKMODULE_GET_CHANNEL_INFO:
+		ch_info = kzalloc(sizeof(*ch_info), GFP_KERNEL);
+		if (!ch_info) {
+			ret = -ENOMEM;
+			return ret;
+		}
 
+		ret = imx708_ioctl(sd, cmd, ch_info);
+		if (!ret) {
+			ret = copy_to_user(up, ch_info, sizeof(*ch_info));
+			if (ret)
+				ret = -EFAULT;
+		}
+		kfree(ch_info);
+		break;
 	default:
 		ret = -ENOIOCTLCMD;
 		break;
 	}
 	return ret;
-
 }
 #endif
 
-static int imx708_enum_frame_interval(struct v4l2_subdev *sd,
-	struct v4l2_subdev_pad_config *cfg,
-	struct v4l2_subdev_frame_interval_enum *fie)
+static int
+imx708_enum_frame_interval(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_frame_interval_enum *fie)
 {
 	struct imx708 *imx708 = to_imx708(sd);
+	const struct imx708_mode *mode_list;
+	unsigned int num_modes, code;
+
+	code = imx708_get_format_code(imx708);
+	get_mode_table(code, &mode_list, &num_modes,
+		       imx708->hdr_mode->val);
 
-	if (fie->index >= imx708->cfg_num)
+	if (fie->index >= num_modes)
 		return -EINVAL;
 
-	fie->code = supported_modes[fie->index].bus_fmt;
-	fie->width = supported_modes[fie->index].width;
-	fie->height = supported_modes[fie->index].height;
-	fie->interval = supported_modes[fie->index].max_fps;
+	fie->code = mode_list[fie->index].bus_fmt;
+	fie->width = mode_list[fie->index].width;
+	fie->height = mode_list[fie->index].height;
+	fie->interval = mode_list[fie->index].max_fps;
 
 	return 0;
 }
@@ -1789,9 +2105,8 @@ static const struct v4l2_subdev_pad_ops imx708_pad_ops = {
 	.enum_frame_interval = imx708_enum_frame_interval,
 	.get_fmt = imx708_get_pad_format,
 	.set_fmt = imx708_set_pad_format,
-	// .get_selection = imx708_get_selection,
+	.get_selection = imx708_get_selection,
 	.set_mbus_config = imx708_g_mbus_config,
-
 };
 
 static const struct v4l2_subdev_ops imx708_subdev_ops = {
@@ -1804,11 +2119,23 @@ static const struct v4l2_subdev_internal_ops imx708_internal_ops = {
 	.open = imx708_open,
 };
 
+static const struct v4l2_ctrl_config imx708_notify_gains_ctrl = {
+	.ops = &imx708_ctrl_ops,
+	.id = V4L2_CID_NOTIFY_GAINS,
+	.type = V4L2_CTRL_TYPE_U32,
+	.min = IMX708_COLOUR_BALANCE_MIN,
+	.max = IMX708_COLOUR_BALANCE_MAX,
+	.step = IMX708_COLOUR_BALANCE_STEP,
+	.def = IMX708_COLOUR_BALANCE_DEFAULT,
+	.dims = { 4 },
+	.elem_size = sizeof(u32),
+};
+
 /* Initialize control handlers */
 static int imx708_init_controls(struct imx708 *imx708)
 {
 	struct v4l2_ctrl_handler *ctrl_hdlr;
-	struct i2c_client *client = v4l2_get_subdevdata(&imx708->subdev);
+	struct i2c_client *client = v4l2_get_subdevdata(&imx708->sd);
 	struct v4l2_fwnode_device_properties props;
 	struct v4l2_ctrl *ctrl;
 	unsigned int i;
@@ -1886,6 +2213,12 @@ static int imx708_init_controls(struct imx708 *imx708)
 		/* The "Solid color" pattern is white by default */
 	}
 
+	v4l2_ctrl_new_custom(ctrl_hdlr, &imx708_notify_gains_ctrl, NULL);
+
+	imx708->hdr_mode = v4l2_ctrl_new_std(ctrl_hdlr, &imx708_ctrl_ops,
+					     V4L2_CID_WIDE_DYNAMIC_RANGE,
+					     0, 1, 1, 0);
+
 	ret = v4l2_fwnode_device_parse(&client->dev, &props);
 	if (ret)
 		goto error;
@@ -1902,8 +2235,9 @@ static int imx708_init_controls(struct imx708 *imx708)
 	imx708->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
 	imx708->hflip->flags |= V4L2_CTRL_FLAG_MODIFY_LAYOUT;
 	imx708->vflip->flags |= V4L2_CTRL_FLAG_MODIFY_LAYOUT;
+	imx708->hdr_mode->flags |= V4L2_CTRL_FLAG_MODIFY_LAYOUT;
 
-	imx708->subdev.ctrl_handler = ctrl_hdlr;
+	imx708->sd.ctrl_handler = ctrl_hdlr;
 
 	/* Setup exposure and frame/line length limits. */
 	imx708_set_framing_limits(imx708);
@@ -1917,6 +2251,12 @@ static int imx708_init_controls(struct imx708 *imx708)
 	return ret;
 }
 
+static void imx708_free_controls(struct imx708 *imx708)
+{
+	v4l2_ctrl_handler_free(imx708->sd.ctrl_handler);
+	mutex_destroy(&imx708->mutex);
+}
+
 static int imx708_check_hwcfg(struct device *dev, struct imx708 *imx708)
 {
 	struct fwnode_handle *endpoint;
@@ -1978,15 +2318,12 @@ static int imx708_probe(struct i2c_client *client,
 	struct device *dev = &client->dev;
 	struct device_node *node = dev->of_node;
 	struct imx708 *imx708;
-    struct v4l2_subdev *sd;
 	char facing[2];
 	int ret;
 	u32 i, hdr_mode = 0;
 
-	dev_info(dev, "driver version: %02x.%02x.%02x",
-		DRIVER_VERSION >> 16,
-		(DRIVER_VERSION & 0xff00) >> 8,
-		DRIVER_VERSION & 0x00ff);
+	dev_info(dev, "driver version: %02x.%02x.%02x", DRIVER_VERSION >> 16,
+		 (DRIVER_VERSION & 0xff00) >> 8, DRIVER_VERSION & 0x00ff);
 
 	imx708 = devm_kzalloc(&client->dev, sizeof(*imx708), GFP_KERNEL);
 	if (!imx708)
@@ -2000,10 +2337,8 @@ static int imx708_probe(struct i2c_client *client,
 				       &imx708->module_name);
 	ret |= of_property_read_string(node, RKMODULE_CAMERA_LENS_NAME,
 				       &imx708->len_name);
-	if (ret) {
-		dev_err(dev, "could not get module information!\n");
+	if (ret)
 		return -EINVAL;
-	}
 
 	ret = of_property_read_u32(node, OF_CAMERA_HDR_MODE, &hdr_mode);
 	if (ret) {
@@ -2012,31 +2347,35 @@ static int imx708_probe(struct i2c_client *client,
 	}
 
 	imx708->client = client;
-	imx708->cfg_num = ARRAY_SIZE(supported_modes);
-	for (i = 0; i < imx708->cfg_num; i++) {
-		if (hdr_mode == supported_modes[i].hdr_mode) {
-			imx708->cur_mode = &supported_modes[i];
-			break;
-		}
-	}
+	v4l2_i2c_subdev_init(&imx708->sd, client, &imx708_subdev_ops);
 
-	if (i >= imx708->cfg_num) {
-		dev_warn(dev, " Get hdr mode failed! no hdr config\n");
-		imx708->cur_mode = &supported_modes[0];
-	}
+	/* Initialize default format */
+	imx708_set_default_format(imx708);
 
-	sd = &imx708->subdev;
-	v4l2_i2c_subdev_init(sd, client, &imx708_subdev_ops);
+	if (hdr_mode != NO_HDR) {
+		imx708->cfg_num = ARRAY_SIZE(supported_modes_10bit_hdr);
+
+		for (i = 0; i < imx708->cfg_num; i++) {
+			if (hdr_mode == supported_modes_10bit_hdr[i].rk_hdr_mode) {
+				imx708->mode = &supported_modes_10bit_hdr[i];
+				break;
+			}
+		}
+
+		if (i >= imx708->cfg_num)
+			dev_warn(dev, " Get hdr mode failed! no hdr config\n");
+	} else
+		imx708->cfg_num = ARRAY_SIZE(supported_modes_10bit_no_hdr);
 
 	/* Check the hardware configuration in device tree */
 	if (imx708_check_hwcfg(dev, imx708))
 		return -EINVAL;
 
 	/* Get system clock (inclk) */
-	imx708->inclk = devm_clk_get(dev, "xclk");
+	imx708->inclk = devm_clk_get(dev, "inclk");
 	if (IS_ERR(imx708->inclk))
 		return dev_err_probe(dev, PTR_ERR(imx708->inclk),
-				     "failed to get xclk\n");
+				     "failed to get inclk\n");
 
 	imx708->inclk_freq = clk_get_rate(imx708->inclk);
 	if (imx708->inclk_freq != IMX708_INCLK_FREQ)
@@ -2049,9 +2388,9 @@ static int imx708_probe(struct i2c_client *client,
 		return dev_err_probe(dev, ret, "failed to get regulators\n");
 
 	/* Request optional enable pin */
-	imx708->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_ASIS);
-	if (IS_ERR(imx708->reset_gpio))
-		dev_warn(dev, "Failed to get reset-gpios\n");
+	imx708->reset_gpio = devm_gpiod_get_optional(dev, "reset",
+						     GPIOD_OUT_HIGH);
+
 	/*
 	 * The sensor must be powered for imx708_identify_module()
 	 * to be able to read the CHIP_ID register
@@ -2064,7 +2403,6 @@ static int imx708_probe(struct i2c_client *client,
 	if (ret)
 		goto error_power_off;
 
-
 	/* Enable runtime PM and turn off the device */
 	pm_runtime_set_active(dev);
 	pm_runtime_enable(dev);
@@ -2074,23 +2412,21 @@ static int imx708_probe(struct i2c_client *client,
 	ret = imx708_init_controls(imx708);
 	if (ret)
 		goto error_pm_runtime;
-#ifdef CONFIG_VIDEO_V4L2_SUBDEV_API
+
 	/* Initialize subdev */
-	sd->internal_ops = &imx708_internal_ops;
-	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+	imx708->sd.internal_ops = &imx708_internal_ops;
+	imx708->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
 			    V4L2_SUBDEV_FL_HAS_EVENTS;
-#endif
-#if defined(CONFIG_MEDIA_CONTROLLER)
+	imx708->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+
 	/* Initialize source pads */
 	imx708->pad.flags = MEDIA_PAD_FL_SOURCE;
-	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
 
-	ret = media_entity_pads_init(&sd->entity, 1, &imx708->pad);
+	ret = media_entity_pads_init(&imx708->sd.entity, 1, &imx708->pad);
 	if (ret) {
 		dev_err(dev, "failed to init entity pads: %d\n", ret);
 		goto error_handler_free;
 	}
-#endif
 
 	memset(facing, 0, sizeof(facing));
 	if (strcmp(imx708->module_facing, "back") == 0)
@@ -2098,11 +2434,11 @@ static int imx708_probe(struct i2c_client *client,
 	else
 		facing[0] = 'f';
 
-	snprintf(sd->name, sizeof(sd->name), "m%02d_%s_%s %s",
+	snprintf(imx708->sd.name, sizeof(imx708->sd.name), "m%02d_%s_%s %s",
 		 imx708->module_index, facing,
-		 IMX708_NAME, dev_name(sd->dev));
+		 IMX708_NAME, dev_name(imx708->sd.dev));
 
-	ret = v4l2_async_register_subdev_sensor_common(&imx708->subdev);
+	ret = v4l2_async_register_subdev_sensor_common(&imx708->sd);
 	if (ret < 0) {
 		dev_err(dev, "failed to register sensor sub-device: %d\n", ret);
 		goto error_media_entity;
@@ -2111,13 +2447,11 @@ static int imx708_probe(struct i2c_client *client,
 	return 0;
 
 error_media_entity:
-#if defined(CONFIG_MEDIA_CONTROLLER)
-	media_entity_cleanup(&sd->entity);
-#endif
+	media_entity_cleanup(&imx708->sd.entity);
 
 error_handler_free:
-	v4l2_ctrl_handler_free(&imx708->ctrl_handler);
-	mutex_destroy(&imx708->mutex);
+	imx708_free_controls(imx708);
+
 error_pm_runtime:
 	pm_runtime_disable(&client->dev);
 	pm_runtime_set_suspended(&client->dev);
@@ -2134,30 +2468,26 @@ static int imx708_remove(struct i2c_client *client)
 	struct imx708 *imx708 = to_imx708(sd);
 
 	v4l2_async_unregister_subdev(sd);
-#if defined(CONFIG_MEDIA_CONTROLLER)
 	media_entity_cleanup(&sd->entity);
-#endif
-	v4l2_ctrl_handler_free(&imx708->ctrl_handler);
-	mutex_destroy(&imx708->mutex);
+	imx708_free_controls(imx708);
 
 	pm_runtime_disable(&client->dev);
 	if (!pm_runtime_status_suspended(&client->dev))
 		imx708_power_off(&client->dev);
 	pm_runtime_set_suspended(&client->dev);
-    return 0;
+
+	return 0;
 }
 
-#if IS_ENABLED(CONFIG_OF)
-static const struct of_device_id imx708_of_match[] = {
+static const struct of_device_id imx708_dt_ids[] = {
 	{ .compatible = "sony,imx708" },
 	{ /* sentinel */ }
 };
-MODULE_DEVICE_TABLE(of, imx708_of_match);
-#endif
+MODULE_DEVICE_TABLE(of, imx708_dt_ids);
 
 static const struct i2c_device_id imx708_match_id[] = {
 	{ "sony,imx708", 0 },
-	{ },
+	{},
 };
 
 static const struct dev_pm_ops imx708_pm_ops = {
@@ -2168,26 +2498,17 @@ static const struct dev_pm_ops imx708_pm_ops = {
 static struct i2c_driver imx708_i2c_driver = {
 	.driver = {
 		.name = "imx708",
-		.of_match_table	= of_match_ptr(imx708_of_match),
+		.of_match_table	= of_match_ptr(imx708_dt_ids),
 		.pm = &imx708_pm_ops,
 	},
 	.probe = &imx708_probe,
 	.remove = &imx708_remove,
-    .id_table	= imx708_match_id,
+	.id_table = imx708_match_id,
 };
 
-static int __init sensor_mod_init(void)
-{
-	return i2c_add_driver(&imx708_i2c_driver);
-}
-
-static void __exit sensor_mod_exit(void)
-{
-	i2c_del_driver(&imx708_i2c_driver);
-}
-
-device_initcall_sync(sensor_mod_init);
-module_exit(sensor_mod_exit);
+module_i2c_driver(imx708_i2c_driver);
 
+MODULE_AUTHOR("UtsavBalar1231 <utsavbalar1231@gmail.com>");
+MODULE_AUTHOR("David Plowman <david.plowman@raspberrypi.com>");
 MODULE_DESCRIPTION("Sony IMX708 sensor driver");
 MODULE_LICENSE("GPL v2");
-- 
2.45.2

